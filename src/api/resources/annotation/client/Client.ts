/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as core from "../../../../core";
import { HumanloopApi } from "@fern-api/humanloop";
import urlJoin from "url-join";
import * as errors from "../../../../errors";
import * as serializers from "../../../../serialization";

export declare namespace Client {
    interface Options {
        environment: string;
        token?: core.Supplier<core.BearerToken>;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    /**
     * Get a page of annotations data for a given project.
     * This endpoint works like `/tasks`, but you must provide
     * `page` and `size` parameters. Up to `size` records
     * will be returned, starting from `page` * `size`.
     * user relates to user.full_name.
     */
    public async getAll(request: HumanloopApi.GetAnnotationsRequest): Promise<void> {
        const _queryParams = new URLSearchParams();
        _queryParams.append("project_id", request.projectId.toString());
        if (request.size != null) {
            _queryParams.append("size", request.size.toString());
        }

        if (request.page != null) {
            _queryParams.append("page", request.page.toString());
        }

        if (request.complete != null) {
            _queryParams.append("complete", request.complete.toString());
        }

        if (request.flagged != null) {
            _queryParams.append("flagged", request.flagged.toString());
        }

        if (request.reviewed != null) {
            _queryParams.append("reviewed", request.reviewed.toString());
        }

        if (request.user != null) {
            _queryParams.append("user", request.user);
        }

        if (request.keywords != null) {
            _queryParams.append("keywords", request.keywords);
        }

        if (request.taskId != null) {
            _queryParams.append("task_id", request.taskId.toString());
        }

        const _response = await core.fetcher({
            url: urlJoin(this.options.environment, "/annotations"),
            method: "GET",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            queryParameters: _queryParams,
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumanloopApiError({
                statusCode: _response.error.statusCode,
                responseBody: _response.error.rawBody,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.HumanloopApiError({
                    statusCode: _response.error.statusCode,
                    responseBody: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.HumanloopApiTimeoutError();
            case "unknown":
                throw new errors.HumanloopApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Create an annotation
     */
    public async create(request: HumanloopApi.CreateAnnotationRequest): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment, "/annotations"),
            method: "POST",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.annotation.create.Request.json({
                taskId: request.taskId,
                externalId: request.externalId,
                labelId: request.labelId,
                start: request.start,
                end: request.end,
                text: request.text,
                strength: request.strength,
            }),
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumanloopApiError({
                statusCode: _response.error.statusCode,
                responseBody: _response.error.rawBody,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.HumanloopApiError({
                    statusCode: _response.error.statusCode,
                    responseBody: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.HumanloopApiTimeoutError();
            case "unknown":
                throw new errors.HumanloopApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Create or update an annotation.
     * This endpoint is only used for single-label classification.
     */
    public async upsert(annotationId: string, request: HumanloopApi.UpsertAnnotationRequest): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment, `/annotations/${annotationId}`),
            method: "PUT",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.annotation.upsert.Request.json({
                taskId: request.taskId,
                labelId: request.labelId,
                start: request.start,
                end: request.end,
                text: request.text,
                strength: request.strength,
            }),
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumanloopApiError({
                statusCode: _response.error.statusCode,
                responseBody: _response.error.rawBody,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.HumanloopApiError({
                    statusCode: _response.error.statusCode,
                    responseBody: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.HumanloopApiTimeoutError();
            case "unknown":
                throw new errors.HumanloopApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Delete a given annotation
     */
    public async delete(annotationId: string): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment, `/annotations/${annotationId}`),
            method: "DELETE",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumanloopApiError({
                statusCode: _response.error.statusCode,
                responseBody: _response.error.rawBody,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.HumanloopApiError({
                    statusCode: _response.error.statusCode,
                    responseBody: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.HumanloopApiTimeoutError();
            case "unknown":
                throw new errors.HumanloopApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Update a given annotation.
     */
    public async update(
        annotationId: string,
        request?: HumanloopApi.UpdateAnnotationRequest
    ): Promise<HumanloopApi.Annotation> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment, `/annotations/${annotationId}`),
            method: "PATCH",
            headers: {
                Authorization: core.BearerToken.toAuthorizationHeader(await core.Supplier.get(this.options.token)),
            },
            body: await serializers.annotation.update.Request.json({
                reviewed: request?.reviewed,
                start: request?.start,
                end: request?.end,
                labelId: request?.labelId,
                strength: request?.strength,
                text: request?.text,
            }),
        });
        if (_response.ok) {
            return await serializers.annotation.update.Response.parse(
                _response.body as serializers.annotation.update.Response.Raw
            );
        }

        if (_response.error.reason === "status-code") {
            throw new errors.HumanloopApiError({
                statusCode: _response.error.statusCode,
                responseBody: _response.error.rawBody,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.HumanloopApiError({
                    statusCode: _response.error.statusCode,
                    responseBody: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.HumanloopApiTimeoutError();
            case "unknown":
                throw new errors.HumanloopApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
}
